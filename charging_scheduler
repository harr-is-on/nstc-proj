# charging_scheduler.py
"""
å¤šå……é›»ç«™èª¿åº¦ç®¡ç†å™¨
æ•´åˆç¾æœ‰ç³»çµ±æ¥å£ï¼Œæä¾›NCSå’ŒMDCSå……é›»ç«™é¸æ“‡ç­–ç•¥
"""
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'test'))

import math
from typing import TYPE_CHECKING, List, Dict, Optional, Tuple

# å°å…¥ç¾æœ‰ç³»çµ±æ¨¡çµ„
from charging_model import ChargingStation
from warehouse_layout import get_station_locations

# å……é›»ç«™é…ç½®ï¼ˆé©æ‡‰harrç‰ˆæœ¬çš„charging_modelï¼‰
CHARGING_STATION_CONFIG = {
    "capacity": 1,
    "charge_rate": 5,
    "charging_threshold": 20,
    "full_charge_level": 100,
}

if TYPE_CHECKING:
    from robot_and_initial_state import Robot

# ä½¿ç”¨ç³»çµ±ç¾æœ‰çš„é¡å‹å®šç¾©
Coord = Tuple[int, int]

def euclidean_distance(pos1: Coord, pos2: Coord) -> float:
    """è¨ˆç®—å…©é»é–“çš„æ­å¹¾é‡Œå¾—è·é›¢"""
    return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)

class ExtendedChargingStation:
    """
    æ“´å±•çš„å……é›»ç«™é¡ï¼ŒåŒ…è£ç¾æœ‰çš„ChargingStationä¸¦æ·»åŠ èª¿åº¦åŠŸèƒ½
    """
    
    def __init__(self, station_id: str, position: Coord, **kwargs):
        self.station_id = station_id
        self.position = position  # å……é›»ç«™ä½ç½®
        
        # ä½¿ç”¨ç¾æœ‰ç³»çµ±çš„å……é›»ç«™å¯¦ä¾‹
        self.charging_station = ChargingStation(**CHARGING_STATION_CONFIG)
        
        # å……é›»é…ç½®
        self.capacity = self.charging_station.capacity
        self.charge_rate = CHARGING_STATION_CONFIG.get('charge_rate', 5)
        
    def is_available(self) -> bool:
        """æª¢æŸ¥æ˜¯å¦æœ‰ç©ºä½å¯ç«‹å³é–‹å§‹å……é›»"""
        return len(self.charging_station.charging) < self.charging_station.capacity
    
    def get_queue_length(self) -> int:
        """å–å¾—ç•¶å‰æ’éšŠé•·åº¦"""
        return len(self.charging_station.queue)
    
    def get_total_robots(self) -> int:
        """å–å¾—å……é›»ç«™ç¸½æ©Ÿå™¨äººæ•¸é‡ï¼ˆå……é›»ä¸­+æ’éšŠä¸­ï¼‰"""
        return len(self.charging_station.charging) + len(self.charging_station.queue)
    
    def estimate_waiting_time(self, target_soc: float = 100.0) -> float:
        """
        ä¼°ç®—æ–°åˆ°é”æ©Ÿå™¨äººçš„ç­‰å¾…æ™‚é–“
        ä½¿ç”¨MDCSæ­£ç¢ºç®—æ³•ï¼šç¸½ç¼ºé¡é›»åŠ› / å……é›»é€Ÿç‡
        
        Args:
            target_soc: ç›®æ¨™é›»é‡ç™¾åˆ†æ¯”
        """
        if self.is_available():
            return 0.0  # æœ‰ç©ºä½ï¼Œç„¡éœ€ç­‰å¾…
        
        # è¨ˆç®—å……é›»ä¸­å’Œæ’éšŠä¸­æ©Ÿå™¨äººçš„ç¸½ç¼ºé¡é›»åŠ›
        total_power_deficit = 0.0
        
        # å……é›»ä¸­çš„æ©Ÿå™¨äºº
        for robot in self.charging_station.charging:
            current_battery = getattr(robot, 'battery_level', 50)  # é»˜èª50%
            deficit = target_soc - current_battery
            if deficit > 0:
                total_power_deficit += deficit
        
        # æ’éšŠä¸­çš„æ©Ÿå™¨äºº  
        for robot in self.charging_station.queue:
            current_battery = getattr(robot, 'battery_level', 50)  # é»˜èª50%
            deficit = target_soc - current_battery
            if deficit > 0:
                total_power_deficit += deficit
        
        # é ä¼°å‰©é¤˜æ™‚é–“ = ç¸½ç¼ºé¡é›»åŠ› / å……é›»é€Ÿç‡
        estimated_time = total_power_deficit / self.charge_rate if self.charge_rate > 0 else 0.0
        
        return estimated_time
    
    def request_charging(self, robot: 'Robot') -> bool:
        """å§”è¨—çµ¦ç¾æœ‰çš„å……é›»ç«™è™•ç†å……é›»è«‹æ±‚"""
        self.charging_station.request_charging(robot)
        return True
    
    def update(self) -> List['Robot']:
        """å§”è¨—çµ¦ç¾æœ‰çš„å……é›»ç«™è™•ç†ç‹€æ…‹æ›´æ–°"""
        return self.charging_station.update()

class ChargingStationManager:
    """
    å¤šå……é›»ç«™ç®¡ç†å™¨
    
    æ•´åˆç¾æœ‰ç³»çµ±ï¼Œè² è²¬ï¼š
    1. è‡ªå‹•åˆå§‹åŒ–2å€‹å……é›»ç«™ï¼ˆå¾warehouse_layoutç²å–ä¿¡æ¯ï¼‰
    2. æ ¹æ“šNCSæˆ–MDCSç­–ç•¥é¸æ“‡æœ€é©åˆçš„å……é›»ç«™
    3. æä¾›èˆ‡ç¾æœ‰ChargingStationç›¸åŒçš„æ¥å£
    """
    
    def __init__(self, strategy: str = "NCS"):
        self.stations: Dict[str, ExtendedChargingStation] = {}
        self.strategy = strategy.upper()  # "NCS" æˆ– "MDCS"
        
        # è‡ªå‹•åˆå§‹åŒ–å……é›»ç«™
        self._initialize_stations()
    
    def _initialize_stations(self):
        """å¾warehouse_layoutè‡ªå‹•åˆå§‹åŒ–å……é›»ç«™"""
        station_layout = get_station_locations()
        charge_stations_info = station_layout.get('charge_stations', [])
        
        for station_info in charge_stations_info:
            station_id = station_info['id']
            position = station_info['pos']
            
            extended_station = ExtendedChargingStation(
                station_id=station_id,
                position=position
            )
            self.stations[station_id] = extended_station
        
        print(f"âœ… åˆå§‹åŒ–äº† {len(self.stations)} å€‹å……é›»ç«™: {list(self.stations.keys())}")
        
    def add_station(self, station: ExtendedChargingStation):
        """æ–°å¢å……é›»ç«™åˆ°ç³»çµ±ä¸­"""
        self.stations[station.station_id] = station
        
    def get_stations_list(self) -> List[ExtendedChargingStation]:
        """å–å¾—æ‰€æœ‰å……é›»ç«™çš„åˆ—è¡¨"""
        return list(self.stations.values())
    
    def request_charging(self, robot: 'Robot') -> Optional[str]:
        """
        ç‚ºæ©Ÿå™¨äººé¸æ“‡å……é›»ç«™ä¸¦å®‰æ’å……é›»
        
        Args:
            robot: éœ€è¦å……é›»çš„æ©Ÿå™¨äºº
            
        Returns:
            Optional[str]: é¸ä¸­çš„å……é›»ç«™IDï¼Œè‹¥ç„¡æ³•å®‰æ’å‰‡å›å‚³None
        """
        if not self.stations:
            print("âš ï¸ æ²’æœ‰å¯ç”¨çš„å……é›»ç«™")
            return None
            
        # æ ¹æ“šç­–ç•¥é¸æ“‡å……é›»ç«™
        if self.strategy == "NCS":
            selected_station = self._select_nearest_station(robot)
        elif self.strategy == "MDCS":
            selected_station = self._select_minimum_delay_station(robot)
        else:
            # é è¨­ç­–ç•¥ï¼šé¸æ“‡ç¬¬ä¸€å€‹å¯ç”¨çš„
            selected_station = next(iter(self.stations.values()))
            
        # å˜—è©¦åœ¨é¸ä¸­çš„å……é›»ç«™å®‰æ’å……é›»
        if selected_station and selected_station.request_charging(robot):
            print(f"ğŸ”‹ æ©Ÿå™¨äºº {robot.id} ä½¿ç”¨ {self.strategy} ç­–ç•¥é¸æ“‡å……é›»ç«™ {selected_station.station_id}")
            return selected_station.station_id
        else:
            print(f"âš ï¸ ç„¡æ³•ç‚ºæ©Ÿå™¨äºº {robot.id} å®‰æ’å……é›»")
            return None
    
    def _select_nearest_station(self, robot: 'Robot') -> Optional[ExtendedChargingStation]:
        """
        NCSç­–ç•¥ï¼šé¸æ“‡è·é›¢æœ€è¿‘çš„å……é›»ç«™
        
        ç®—æ³•ï¼šè¨ˆç®—æ©Ÿå™¨äººç•¶å‰ä½ç½®åˆ°å„å……é›»ç«™çš„è·é›¢ï¼Œé¸æ“‡æœ€è¿‘çš„
        """
        if not self.stations:
            return None
        
        robot_position = robot.position
        best_station = None
        min_distance = float('inf')
        
        print(f"ğŸ” NCSç­–ç•¥ç‚ºæ©Ÿå™¨äºº {robot.id} é¸æ“‡å……é›»ç«™:")
        
        for station in self.stations.values():
            distance = euclidean_distance(robot_position, station.position)
            print(f"  {station.station_id}: è·é›¢ {distance:.1f}")
            
            # é¸æ“‡è·é›¢æœ€è¿‘çš„å……é›»ç«™
            if distance < min_distance:
                min_distance = distance
                best_station = station
        
        if best_station:
            print(f"  âœ… é¸æ“‡ {best_station.station_id} (æœ€çŸ­è·é›¢: {min_distance:.1f})")
        
        return best_station
    
    def _select_minimum_delay_station(self, robot: 'Robot') -> Optional[ExtendedChargingStation]:
        """
        MDCSç­–ç•¥ï¼šé¸æ“‡ç¸½å»¶é²æœ€å°çš„å……é›»ç«™
        
        æ­£ç¢ºç®—æ³•ï¼š
        1. Travel time = è·é›¢ / æ©Ÿå™¨äººé€Ÿåº¦
        2. é ä¼°å‰©é¤˜æ™‚é–“ = (ç›®æ¨™SOC - å……é›»ä¸­&æ’éšŠä¸­æ©Ÿå™¨äººç•¶å‰é›»åŠ›ç¸½å’Œ) / å……é›»é€Ÿç‡
        3. ç¸½å»¶é² = Travel time + é ä¼°å‰©é¤˜æ™‚é–“
        4. é¸æ“‡ç¸½å»¶é²æœ€å°çš„å……é›»ç«™
        """
        if not self.stations:
            return None
        
        best_station = None
        min_total_delay = float('inf')
        
        robot_position = robot.position
        robot_speed = getattr(robot, 'move_speed', 1)
        target_soc = CHARGING_STATION_CONFIG.get('full_charge_level', 100)  # ç›®æ¨™SOC
        
        print(f"ğŸ” MDCSç­–ç•¥ç‚ºæ©Ÿå™¨äºº {robot.id} é¸æ“‡å……é›»ç«™:")
        
        for station in self.stations.values():
            # 1. è¨ˆç®—å‰å¾€æ™‚é–“ (Travel time)
            distance = euclidean_distance(robot_position, station.position)
            travel_time = distance / robot_speed
            
            # 2. è¨ˆç®—é ä¼°å‰©é¤˜æ™‚é–“ï¼ˆåŸºæ–¼å¯¦éš›æ©Ÿå™¨äººé›»é‡ï¼‰
            estimated_remaining_time = station.estimate_waiting_time(target_soc)
            
            # 3. è¨ˆç®—ç¸½å»¶é²
            total_delay = travel_time + estimated_remaining_time
            
            print(f"  {station.station_id}: è·é›¢{distance:.1f} -> è¡Œé§›æ™‚é–“{travel_time:.1f} + é ä¼°å‰©é¤˜æ™‚é–“{estimated_remaining_time:.1f} = ç¸½å»¶é²{total_delay:.1f}")
            
            # 4. æ›´æ–°æœ€ä½³é¸æ“‡
            if total_delay < min_total_delay:
                min_total_delay = total_delay
                best_station = station
        
        if best_station:
            print(f"  âœ… é¸æ“‡ {best_station.station_id} (ç¸½å»¶é²: {min_total_delay:.1f})")
        
        return best_station
    
    # æä¾›èˆ‡ç¾æœ‰ChargingStationç›¸åŒçš„æ¥å£ï¼Œä»¥ä¾¿ç„¡ç¸«æ•´åˆ
    def update(self) -> List['Robot']:
        """æ›´æ–°æ‰€æœ‰å……é›»ç«™ä¸¦æ”¶é›†å®Œæˆå……é›»çš„æ©Ÿå™¨äºº"""
        all_finished_robots = []
        
        for station in self.stations.values():
            finished_robots = station.update()
            all_finished_robots.extend(finished_robots)
        
        return all_finished_robots
    
    def get_system_status(self) -> Dict[str, Dict]:
        """å–å¾—æ•´å€‹å……é›»ç³»çµ±çš„ç‹€æ…‹ç¸½è¦½"""
        status = {}
        
        for station_id, station in self.stations.items():
            charging_count = len(station.charging_station.charging)
            status[station_id] = {
                'position': station.position,
                'charging_count': charging_count,
                'queue_length': station.get_queue_length(),
                'capacity': station.capacity,
                'utilization': charging_count / station.capacity if station.capacity > 0 else 0,
                'estimated_waiting': station.estimate_waiting_time()
            }
            
        return status

# ä½¿ç”¨ç¯„ä¾‹å’Œæ¸¬è©¦åŠŸèƒ½
def create_charging_system(strategy: str = "MDCS") -> ChargingStationManager:
    """
    å‰µå»ºå……é›»ç«™ç®¡ç†ç³»çµ±
    
    Args:
        strategy: å……é›»ç«™é¸æ“‡ç­–ç•¥ï¼Œ"NCS" æˆ– "MDCS"
    
    Returns:
        ChargingStationManager: åˆå§‹åŒ–å®Œæˆçš„å……é›»ç«™ç®¡ç†å™¨
    """
    manager = ChargingStationManager(strategy=strategy)
    return manager

def demonstrate_system():
    """æ¼”ç¤ºç³»çµ±åŠŸèƒ½"""
    print("ğŸ”‹ å……é›»ç«™èª¿åº¦ç³»çµ±æ¼”ç¤º")
    print("=" * 50)
    
    # å‰µå»ºMDCSç­–ç•¥çš„ç®¡ç†å™¨
    manager = create_charging_system("MDCS")
    
    # é¡¯ç¤ºç³»çµ±ç‹€æ…‹
    print("\nğŸ“Š ç³»çµ±ç‹€æ…‹:")
    status = manager.get_system_status()
    for station_id, info in status.items():
        print(f"  {station_id}: ä½ç½®{info['position']}, å®¹é‡{info['charging_count']}/{info['capacity']}, "
              f"æ’éšŠ{info['queue_length']}, ç­‰å¾…æ™‚é–“{info['estimated_waiting']:.1f}")
    
    print(f"\nâœ… å……é›»ç«™èª¿åº¦ç³»çµ±åˆå§‹åŒ–å®Œæˆï¼Œä½¿ç”¨ç­–ç•¥: {manager.strategy}")
    return manager

if __name__ == "__main__":
    # é‹è¡Œæ¼”ç¤º
    demonstrate_system()
